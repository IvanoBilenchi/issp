# Alice and Bob want to exchange messages over an insecure channel.
# They decide to use a symmetric cipher and a MAC to ensure their confidentiality and authenticity.
# To make their communication more secure, they opt to use random 32 bytes ephemeral keys
# generated using a hash-based PRNG, for which they previously agreed on the initial state.
#
# Mallory is an attacker who has access to the communication channel between Alice and Bob,
# but does not know the initial state of their hash RNG. However, she knows the exact security
# stack they are using (ChaCha20 + HMAC), as well as the key sizes, and also that
# the RNG is used to compute the HMAC key first, and then the encryption key.
#
# Your task is to:
# 1. Implement the hash RNG, based on computing the SHA-256 hash of an increasing counter value.
#    Numbers generated by this RNG should be 64-bit integers.
# 2. Allow Mallory to tamper with the communication by correctly guessing the initial state
#    of the RNG and exploiting this information to send a forged message to Bob.
#
# Hints:
# - You can use the MAC provided in the message to verify if a guessed seed is correct.
# - Keys are generated using the `bytes` method of the `RNG` base class. This method works
#   by repeatedly calling `__next__` and concatenating the results until the requested length
#   is reached. You should take this into account when trying to generate the enctyption key
#   after finding the seed used to generate the HMAC key.


from issp import HMAC, RNG, Actor, ChaCha20, Channel, Message, log, run_main, sha256

KEY_SIZE = 32


class SHA256RNG(RNG[int]):
    VALUE_SIZE = 8

    def __init__(self) -> None:
        self._counter = 12345

    def __next__(self) -> int:
        output = sha256(self._counter.to_bytes(self.VALUE_SIZE))
        self._counter += 1
        return int.from_bytes(output[: self.VALUE_SIZE])

    def set_seed(self, seed: int) -> None:
        self._counter = seed


def alice(channel: Channel, rng: SHA256RNG) -> None:
    channel = channel.with_stack(ChaCha20(rng.bytes(KEY_SIZE)) | HMAC(key=rng.bytes(KEY_SIZE)))
    channel.send(Message("Alice", "Bob", "Hello, Bob!"))


def bob(channel: Channel, rng: SHA256RNG) -> None:
    channel = channel.with_stack(ChaCha20(rng.bytes(KEY_SIZE)) | HMAC(key=rng.bytes(KEY_SIZE)))
    channel.receive("Bob")


def mallory(channel: Channel) -> None:
    msg = channel.receive()

    rng = SHA256RNG()
    hmac = HMAC()
    seed = 0

    body = msg.body[hmac.code_size :]
    mac = msg.body[: hmac.code_size]

    for seed in range(2**64):
        rng.set_seed(seed)
        hmac.key = rng.bytes(KEY_SIZE)
        if hmac.verify(body, mac):
            log.info("[Mallory] Found seed: %d", seed)
            break

    rng.set_seed(seed)
    mac_key = rng.bytes(KEY_SIZE)

    # The encryption key is 32 bytes long, and it was generated after the HMAC key.
    # Since SHA256RNG outputs 64 bit (8 byte) numbers, we need to "rewind" the
    # RNG by 4 outputs (4 * 8 = 32 bytes).
    rng.set_seed(seed - 4)
    enc_key = rng.bytes(KEY_SIZE)

    channel = channel.with_stack(ChaCha20(enc_key) | HMAC(key=mac_key))
    msg.body = "Screw you, Bob!"
    channel.send(msg)


def main() -> None:
    alice_rng = SHA256RNG()

    for i in range(10):
        log.info("[SHA256 RNG] Value %d: %d", i + 1, next(alice_rng))

    seed = 12345
    bob_rng = SHA256RNG()
    alice_rng.set_seed(seed)
    bob_rng.set_seed(seed)

    Actor.start(
        Actor(alice, data=(alice_rng,)),
        Actor(bob, data=(bob_rng,)),
        Actor(mallory, priority=1),
    )


if __name__ == "__main__":
    run_main(main)
